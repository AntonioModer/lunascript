-- match empty blocks
do end

-- match lots of expressions
do exp1 exp2 exp3 end

-- if
if something = test then
  somethingelse
  (test)
elseif somethingelse then
  yay
else
  default
end

do
  test
  test2
end

-- binary expressions
(420 + 69) * 3 - (20 / 2) + do nothing end - if money then 'happy' else 'get money' end
true or false
false and true

-- unary expressions
-#stuff
#a % b + 1
~0xFFFF

-- assignment
a = 0
a += 5
a *= 10
a /= 2
a -= 7

a = b = c = 420

-- varlists / explists
test
a, b, c = 1 + 1, 10 / 2

-- variable indexing / prefixes
foo.bar
foo.bar.baz
thing[some *= stuff + 1].foo['bar'][baz / baz / baz] = 'baz' * (hello /= world)

-- function definition
function empty() end
function full()
  test = 'foo'
  test = 'bar'
end

function args(a, b, c)
  -- return 1, 2, 3
end

-- anon function + varargs
function() end
function(hello, world, hello.world['world'], ...)
  test1, test2 = ...
end

function constructor(self, self.x, (a + b + c).y)
end


function foo.bar() end
function foo.bar:baz() end

-- function call
test()
test(1, 2, 3)(hello, ...)(..., world)
test.test()
test.test:test()

if success() then
  print('yay!')
end

-- expression terminators
test.test:test()(a, b, c)(1, 2, 3)
(1 + 2 - 3 / test)(test, test, test, ...)(test, ..., test)
test(1, 2, 3);;;; (hello)(world)
;yo;dawg;i;herd;u;like;semicolons;

-- test['test'].test[test]:test()
